/*
  //1, f1, set to f1 term
  Memory1[0000000000000000000000000100] = 00000000; 
  Memory2[0000000000000000000000000100] = 00000000;
  Memory3[0000000000000000000000000100] = 00000000;
  Memory4[0000000000000000000000000100] = 00000001;
  //2, initial starting index
  Memory1[0000000000000000000000001000] = 00000000; 
  Memory2[0000000000000000000000001000] = 00000000;
  Memory3[0000000000000000000000001000] = 00000000;
  Memory4[0000000000000000000000001000] = 00000010;
  //11, the last term we need to compute(for checking whether the last term)
  Memory1[0000000000000000000000001100] = 00000000; 
  Memory2[0000000000000000000000001100] = 00000000;
  Memory3[0000000000000000000000001100] = 00000000;
  Memory4[0000000000000000000000001100] = 00001011;
  //Needed Registers here
  //t0, initialized to zero for now
  Memory1[0000000000000000000000010000] = 00000000; 
  Memory2[0000000000000000000000010000] = 00000000;
  Memory3[0000000000000000000000010000] = 00000000;
  Memory4[0000000000000000000000010000] = 00000000;
  //t1, initialized to zero for now
  Memory1[0000000000000000000000010100] = 00000000; 
  Memory2[0000000000000000000000010100] = 00000000;
  Memory3[0000000000000000000000010100] = 00000000;
  Memory4[0000000000000000000000010100] = 00000000;
  //t2, initialized to zero for now
  Memory1[0000000000000000000000011000] = 00000000; 
  Memory2[0000000000000000000000011000] = 00000000;
  Memory3[0000000000000000000000011000] = 8'b00000000;
  Memory4[0000000000000000000000011000] = 8'b00000000;
  //t3, initialized to zero for now
  Memory1[0000000000000000000000100000] = 8'b00000000; 
  Memory2[0000000000000000000000100000] = 8'b00000000;
  Memory3[0000000000000000000000100000] = 8'b00000000;
  Memory4[0000000000000000000000100000] = 8'b00000000;
  //t4, initialized to zero for now
  Memory1[0000000000000000000000100100] = 8'b00000000; 
  Memory2[0000000000000000000000100100] = 8'b00000000;
  Memory3[0000000000000000000000100100] = 8'b00000000;
  Memory4[0000000000000000000000100100] = 8'b00000000;

//--------------------PROGRAM LINES START HERE---------------------------

  //Hard coded instruction lines into the memory
  //MAR = 0000 0001, AC=MBR=1    Load info from MAR into MBR then to AC
  Memory1[0000000000000000000000101000] = 8'b01100000;
  Memory2[0000000000000000000000101000] = 8'b00000000;
  Memory3[0000000000000000000000101000] = 8'b00000000;
  Memory4[0000000000000000000000101000] = 8'b00000100;
  //MAR = address of t0, MBR=AC=1, t0 = 1 Put f1 term into t0
  Memory1[0000000000000000000000101100] = 8'b01110000;
  Memory2[0000000000000000000000101100] = 8'b00000000;
  Memory3[0000000000000000000000101100] = 8'b00000000;
  Memory4[0000000000000000000000101100] = 8'b00010000;
  //MAR = address of t1, MBR=AC=1, t1 = 1 Put f2 term into t1
  Memory1[0000000000000000000000110000] = 8'b01110000;
  Memory2[0000000000000000000000110000] = 8'b00000000;
  Memory3[0000000000000000000000110000] = 8'b00000000;
  Memory4[0000000000000000000000110000] = 8'b00010100;
  //Clear AC
  Memory1[0000000000000000000000110100] = 8'b10000000;
  Memory2[0000000000000000000000110100] = 8'b00000000;
  Memory3[0000000000000000000000110100] = 8'b00000000;
  Memory4[0000000000000000000000110100] = 8'b00000000;
  //AC = 0, MAR = address of t2, MBR = AC = 0, t2 = 0 (This is the fibonacci term)
  Memory1[0000000000000000000000111000] = 8'b01110000;
  Memory2[0000000000000000000000111000] = 8'b00000000;
  Memory3[0000000000000000000000111000] = 8'b00000000;
  Memory4[0000000000000000000000111000] = 8'b00011000;
  //MAR = address of 2 the number, AC=MBR=2, load 2 to AC
  Memory1[0000000000000000000000111100] = 8'b01100000;
  Memory2[0000000000000000000000111100] = 8'b00000000;
  Memory3[0000000000000000000000111100] = 8'b00000000;
  Memory4[0000000000000000000000111100] = 8'b00001000;
  //MAR = address of t3, MBR=AC=2, t3 = 2, (store 2 into t3, for start index of loop)
  Memory1[0000000000000000000001000000] = 8'b01110000;
  Memory2[0000000000000000000001000000] = 8'b00000000;
  Memory3[0000000000000000000001000000] = 8'b00000000;
  Memory4[0000000000000000000001000000] = 8'b00011100;
  //MAR = address of 11 the number, AC=MBR=11
  Memory1[0000000000000000000001000100] = 8'b01100000;
  Memory2[0000000000000000000001000100] = 8'b00000000;
  Memory3[0000000000000000000001000100] = 8'b00000000;
  Memory4[0000000000000000000001000100] = 8'b00001100;
  //MAR = address of t4, MBR = AC = t4 = 11 (store 2 into t3, for end index of loop)
  Memory1[0000000000000000000001001000] = 8'b01110000;
  Memory2[0000000000000000000001001000] = 8'b00000000;
  Memory3[0000000000000000000001001000] = 8'b00000000;
  Memory4[0000000000000000000001001000] = 8'b00100000;
  //Loop (I'm gonna leave this empty for now)
  Memory1[0000000000000000000001001100] = ;
  Memory2[0000000000000000000001001100] = ;
  Memory3[0000000000000000000001001100] = ;
  Memory4[0000000000000000000001001100] = ;
  //MAR = address of t0, AC=MBR=t0=1 (since f1 = f(n-2) = 1)
  Memory1[0000000000000000000001010000] = 8'b01100000;
  Memory2[0000000000000000000001010000] = 8'b00000000;
  Memory3[0000000000000000000001010000] = 8'b00000000;
  Memory4[0000000000000000000001010000] = 8'b00010000;
  //MAR = address of t1, MBR=t1, AC = AC+MBR = t0+t1 = 2 (computes f3 term)
  Memory1[0000000000000000000001010100] = 8'b00000000;
  Memory2[0000000000000000000001010100] = 8'b00000000;
  Memory3[0000000000000000000001010100] = 8'b00000000;
  Memory4[0000000000000000000001010100] = 8'b00010100;
  //Store the value into t2, which holds our computed fibonacci number
  Memory1[0000000000000000000001011000] = 8'b01110000;
  Memory2[0000000000000000000001011000] = 8'b00000000;
  Memory3[0000000000000000000001011000] = 8'b00000000;
  Memory4[0000000000000000000001011000] = 8'b00011000;
  //MAR = address of t1, AC=MBR=t1
  Memory1[0000000000000000000001011100] = 8'b01100000;
  Memory2[0000000000000000000001011100] = 8'b00000000;
  Memory3[0000000000000000000001011100] = 8'b00000000;
  Memory4[0000000000000000000001011100] = 8'b00010100;
  //MAR = address of t0, t0 = AC = MBR = t1
  //(move content in t1 into t0, f(n-1) became the f(n-2) for the next calculation)
  Memory1[0000000000000000000001100000] = 8'b01110000;
  Memory2[0000000000000000000001100000] = 8'b00000000;
  Memory3[0000000000000000000001100000] = 8'b00000000;
  Memory4[0000000000000000000001100000] = 8'b00010000;
  //MAR = address of t2, AC=MBR=t2
  Memory1[0000000000000000000001100100] = 8'b01100000;
  Memory2[0000000000000000000001100100] = 8'b00000000;
  Memory3[0000000000000000000001100100] = 8'b00000000;
  Memory4[0000000000000000000001100100] = 8'b00011000;
  //MAR = address of t1, t1 = AC = MBR = t2
  //(move content in t2 into t1, current fibonacci number became the f(n-1) for the next calculation)
  Memory1[0000000000000000000001101000] = 8'b01110000;
  Memory2[0000000000000000000001101000] = 8'b00000000;
  Memory3[0000000000000000000001101000] = 8'b00000000;
  Memory4[0000000000000000000001101000] = 8'b00010100;
  //MAR = address of t3, AC=MBR=t3
  Memory1[0000000000000000000001101100] = 8'b01100000;
  Memory2[0000000000000000000001101100] = 8'b00000000;
  Memory3[0000000000000000000001101100] = 8'b00000000;
  Memory4[0000000000000000000001101100] = 8'b00011100;
  //MAR = address of 1(the number), MBR=1, AC = AC+1 = t3+1(calculate incrementation)
  Memory1[0000000000000000000001110000] = 8'b00000000;
  Memory2[0000000000000000000001110000] = 8'b00000000;
  Memory3[0000000000000000000001110000] = 8'b00000000;
  Memory4[0000000000000000000001110000] = 8'b00000100;
  //MAR = address of t3, MBR = AC = t3 = t3+1 (update the index with incremented index)
  Memory1[0000000000000000000001110100] = 8'b01110000;
  Memory2[0000000000000000000001110100] = 8'b00000000;
  Memory3[0000000000000000000001110100] = 8'b00000000;
  Memory4[0000000000000000000001110100] = 8'b00011100;
  //MAR = address of t3, AC=MBR=t3
  Memory1[0000000000000000000001111000] = 8'b01100000;
  Memory2[0000000000000000000001111000] = 8'b00000000;
  Memory3[0000000000000000000001111000] = 8'b00000000;
  Memory4[0000000000000000000001111000] = 8'b00011100;
  //MAR = address of t4, MBR = t4. AC = AC-MBR = t3-t4 (to check whether t3 = t4)
  Memory1[0000000000000000000001111100] = 8'b00010000;
  Memory2[0000000000000000000001111100] = 8'b00000000;
  Memory3[0000000000000000000001111100] = 8'b00000000;
  Memory4[0000000000000000000001111100] = 8'b00100000;
  //MAR = address of t4, MBR = t4. AC = AC-MBR = t3-t4 (if t3 = t4 = 11, skip to halt)
  //I'm not sure if this line is right
  Memory1[0000000000000000000010000000] = 8'b10010000;
  Memory2[0000000000000000000010000000] = 8'b00000000;
  Memory3[0000000000000000000010000000] = 8'b00000000;
  Memory4[0000000000000000000010000000] = 8'b00001000;
  //Jump to loop tag
  Memory1[0000000000000000000010000100] = 8'b10100000;
  Memory2[0000000000000000000010000100] = 8'b00000000;
  Memory3[0000000000000000000010000100] = 8'b00000000;
  Memory4[0000000000000000000010000100] = 8'b00110000;
  //AC=MBR=t2(f11), use $display to check testbench
  Memory1[0000000000000000000010001000] = 8'b01100000;
  Memory2[0000000000000000000010001000] = 8'b00000000;
  Memory3[0000000000000000000010001000] = 8'b00000000;
  Memory4[0000000000000000000010001000] = 8'b00110000;
  //Stop PC from incrementing, stops program from continue 
  Memory1[0000000000000000000010001100] = 8'b01010000;
  Memory2[0000000000000000000010001100] = 8'b00000000;
  Memory3[0000000000000000000010001100] = 8'b00000000;
  Memory4[0000000000000000000010001100] = 8'b00000000;
*/